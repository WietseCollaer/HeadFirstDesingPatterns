# Reading Group Head First Design Patterns

This project is a result of the reading group about design patterns. Starting the 6th of june, every week there will be a meetup and a new
design pattern will be added to this repo.

## Strategy Pattern (06/06/2019)
**Strategy Pattern:**
The strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently
 from clients that use it.

**Hosted by:** Wietse Collaer

**Next Host:** Wietse Collaer

## Observer Pattern (13/06/2019)
**Observer Pattern:**
The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state,
all of its dependents are notified and updated automatically.

**Hosted by:** Wietse Collaer

**Next Host:** Maxime Orione

## Decorator Pattern (20/06/2019)
**Decorator Pattern:**
The Decorator Pattern attaches additional responsibilities to an object dynamically.
Decorators provide a flexible alternative to subclassing for extending functionality.

**Hosted by:** Maxime Orione

**Next Host:** Alexandre Vettas

## Factory Pattern (27/06/2019)
**Factory Method Pattern:**
The Factory Method Pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

**Abstract Factory Pattern:**
The Abstract Factory Pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.

**Hosted by:** Alexandre Vettas

**Next Host:** Wietse Collaer

## Singleton Pattern (04/07/2019)
**Singleton Pattern:** The Singleton Pattern ensures a class has only one instance, and provides a global point of access to it.

**Hosted by:** Wietse Collaer

**Next Host:** Alexandre Vettas

## Command Pattern (11/07/2019)
**Command Pattern:** The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.

**Hosted by:** Alexandre Vettas

**Next Host:** Maxime Orione

## Adapter & Facade Pattern (18/07/2019)
**Adapter Pattern:** Converts the interface of a class into another interface clients expect. Lets classes work together that couldn't otherwise because of incompatible interfaces.
**Facade Pattern:** Provides a minified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

**Hosted by:** Maxime Orione

**Next Host:** Wietse Collaer

## Template Method Pattern (25/07/2019)
**Template Method Pattern:** The Template Method Pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses.
Template Method lets the subclasses redefine certain steps of an algorithm without changing the algorithm's structure.

**Hosted by:** Wietse Collaer

**Next Host:** Alexandre Vettas 

## Iterator and Composite Patterns (29/08/2019)
**The Iterator Pattern:** The Iterator Pattern provides a way to access the elements of an aggregate object sequentially without expoing its underlying representation.

**The Composite Pattern:** The Composite Pattern allows you to compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

**Hosted by:** Alexandre Vettas

**Next Host:** Wietse Collaer

## The State Pattern (19/09/2019)
**The State Pattern:** The State Pattern allows an object to alter its behavior
when its internal state changes. The object will appear to change its class.

**Hosted by:** Wietse Collaer

**Next host:** Max Orione 
